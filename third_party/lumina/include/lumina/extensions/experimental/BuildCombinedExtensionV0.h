/*
 * Copyright 2025-present Alibaba Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

// Generated by NewClass.py â€” edit as needed.

#include <cstddef>
#include <cstdint>
#include <lumina/api/Dataset.h>
#include <lumina/api/Extension.h>
#include <lumina/api/LuminaSearcher.h>
#include <lumina/api/Options.h>
#include <lumina/core/Constants.h>

#include <lumina/extensions/experimental/CkptManager.h>

namespace lumina::extensions { inline namespace experimental {

enum class BuildExtension : uint8_t { checkpoint = 1, label = 2, sparse = 4 };
using RoleMask = uint8_t;

template <auto A>
struct RoleSet;

template <RoleMask Mask>
struct RoleSet<Mask> {
    static constexpr RoleMask Value = Mask;
    static constexpr bool Has(BuildExtension e) noexcept { return (Mask & static_cast<uint8_t>(e)) != 0; }
    static std::string_view Name() noexcept
    {
        static std::string Name = []() -> auto {
            std::string ret;
            if (Mask & static_cast<uint8_t>(BuildExtension::checkpoint)) {
                ret += "checkpoint";
            }
            if (Mask & static_cast<uint8_t>(BuildExtension::label)) {
                ret += "label";
            }
            if (Mask & static_cast<uint8_t>(BuildExtension::sparse)) {
                ret += "sparse";
            }
            return ret;
        }();
        return Name;
    }
};

template <BuildExtension MaskE>
struct RoleSet<MaskE> : public RoleSet<static_cast<uint8_t>(MaskE)> {
};

class InnerCkptManager;

template <typename T>
class BuildCombinedExtensionV0;

template <>
class BuildCombinedExtensionV0<RoleSet<BuildExtension::checkpoint>> final : public api::IBuildExtension
{
public:
    BuildCombinedExtensionV0();
    ~BuildCombinedExtensionV0();
    static inline std::string_view ExtensionName() { return RoleSet<BuildExtension::checkpoint>::Name(); }

    using FuncType = std::function<core::Status(std::unique_ptr<InnerCkptManager>)>;

    inline std::string_view Name() const noexcept override { return ExtensionName(); }

    core::Status LoadCkptManager(std::unique_ptr<CkptManager> manager) noexcept;

    inline void SetFunc(FuncType func) noexcept { _func = func; }

private:
    FuncType _func;
};

using BuildWithCheckpointExtension = BuildCombinedExtensionV0<RoleSet<BuildExtension::checkpoint>>;
}} // namespace lumina::extensions::experimental
